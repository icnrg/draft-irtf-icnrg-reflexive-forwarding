<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<rfc
   	xmlns:xi="http://www.w3.org/2001/XInclude"
   	version="3"
    ipr="trust200902"
    docName="draft-irtf-icnrg-reflexive-forwarding-01"
    category="exp"
    submissionType="IRTF"
    updates="8569, 8609"
    consensus="false"
    sortRefs="true"
    symRefs="true"
    tocDepth="4">

<front>

    <title abbrev="ICN Reflexive Forwarding">
    Reflexive Forwarding for CCNx and NDN Protocols</title>
    <seriesInfo 
    	name="Internet-Draft" 
    	value="draft-irtf-icnrg-reflexive-forwarding-01"/>

    <!-- add "role="editor"" below for the editors if appropriate -->
    <author fullname="Dave Oran" initials="D." surname="Oran">
      <organization>Network Systems Research and Design</organization>
      <address>
        <postal>
          <street>4 Shady Hill Square</street>
          <!-- Reorder these if your country does things differently -->
          <city>Cambridge</city>
          <region>MA</region>
          <code>02138</code>
          <country>USA</country>
        </postal>
        <phone></phone>
        <email>daveoran@orandom.net</email>
        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Dirk Kutscher" initials="D." surname="Kutscher">
      <organization>HKUST(GZ)</organization>
      <address>
        <postal>
          <city>Guangzhou</city>
          <country>China</country>
        </postal>
        <phone></phone>
        <email>ietf@dkutscher.net</email>
        <uri>https://dirk-kutscher.info</uri>
      </address>
    </author>

    <author initials="H" surname="Asaeda" fullname="Hitoshi Asaeda">
      <organization abbrev="NICT">National Institute of Information and Communications Technology</organization>
      <address>
        <postal>
          <street>4-2-1 Nukui-Kitamachi</street>
		  <city>Koganei</city>
          <region>Tokyo</region>
          <code>184-8795</code>
          <country>Japan</country>
        </postal>
        <email>asaeda@nict.go.jp</email>
      </address>
    </author>
    
    <author initials="K" surname="Calvert" fullname="Kenneth Calvert">
      <organization>University of Kentucky</organization>
      <address>
      	<postal>
      		<street>289 Rose Street</street>
      		<city>Lexington</city>
      		<region>KY</region>
      		<code>40506-0495</code>
      		<country>USA</country>
      	</postal>
      	<email>calvert@netlab.uky.edu</email>
      </address>
    </author>

<!--     <date month="March" year="2020" /> -->

    <!-- Meta-data Declarations -->
    <workgroup>ICNRG</workgroup>

    <keyword>ICN</keyword>
    <keyword>Information-centric Networking</keyword>
    <keyword>forwarding</keyword>

    <abstract>
      <t>
	Current Information-Centric Networking protocols such as CCNx
	and NDN have a wide range of useful applications in content
	retrieval and other scenarios that depend only on a robust
	two-way exchange in the form of a request and response
	(represented by an <em>Interest-Data exchange</em> in the case
	of the two protocols noted above). A number of important
	applications however, require placing large amounts of data in
	the Interest message, and/or more than one two-way
	handshake. While these can be accomplished using independent
	Interest-Data exchanges by reversing the roles of consumer and
	producer, such approaches can be both clumsy for applications
	and problematic from a state management, congestion control,
	or security standpoint. This specification proposes a
	<em>Reflexive Forwarding</em> extension to the CCNx and NDN
	protocol architectures that eliminates the problems inherent
	in using independent Interest-Data exchanges for such
	applications. It updates RFC8569 and RFC8609.
      </t>
    </abstract>
</front>

<middle>
<section anchor="intro"><name>Introduction</name>
  <t>
    Current ICN protocols such as <xref target="RFC8569">CCNx</xref>
    and <xref target="NDN">NDN</xref> have a wide range of useful
    applications in content retrieval and other scenarios that depend
    only on a robust two-way exchange in the form of a request and
    response. These ICN architectures use the terms "consumer" and
    "producer" for the respective roles of the requester and the
    responder, and the protocols directly capture the mechanics of the
    two-way exchange through the "Interest message" carrying the
    request, and the "Data message" carrying the response. Through
    these constructs, the protocols are heavily biased toward a pure
    <em>pull-based</em> interaction model where requests are small
    (carrying little or no user-supplied data other than the name of
    the requested data object), and responses are relatively large -
    up to an architecture-defined maximum transmission unit (MTU) on
    the order of kilobytes or tens of kilobytes.
  </t>

  <t>
    A number of important applications however require interaction
    models more complex than individual request/response interactions
    in the same direction (i.e. between the same consumer and one or
    more producers). Among these we identify three important classes
    which are the target of the proposed enhancements defined in this
    specification. These are described in the following paragraphs.
  </t>
  <dl>
    <dt><strong>Remote Method Invocation (RMI, aka RPC):</strong></dt>
    <dd>
      When invoking a remote method, it is common for the method to
      require arguments supplied by the caller. In conventional TCP/IP
      style protocols like CORBA or HTTP "Post", these are pushed to
      the server as part of the message or messages that comprise the
      request. In ICN-style protocols there is an unattractive choice
      between inflating the request initiation with pushed arguments,
      or arranging to have one or more independent request/response pairs
      in the opposite direction for the server to fetch the
      arguments. Both of these approaches have substantial
      disadvantages. Recently, a viable alternative emerged through
      the work on <xref target="Krol2018">RICE</xref> which pioneered
      the main design elements proposed in this specification.
    </dd>
    <dt><strong>Phone-Home scenario:</strong></dt>
    <dd>
      Applications in sensing, Internet-of-things (IoT) and other
      types where data is produced unpredictably and needs to be
      <em>pushed</em> somewhere create a conundrum for the pure
      pull-based architectures considered here. If instead one eschews
      relaxing the size asymmetry between requests and responses, some
      additional protocol machinery is needed. Earlier efforts in the
      ICN community have recognized this issue and designed methods to
      provoke a cooperating element to issue a request to return the
      data the originator desires to push, essentially "phoning home"
      to get the responder to fetch the data. One that has been
      explored to some extent is the <em>Interest-Interest-Data</em>
      exchange <xref target="Carzaniga2011"/>, where an Interest is
      sent containing the desired request as encapsulated
      data. CCNx-1.0 Bidirectional Streams <xref target="Mosko2017"/>
      are also based on a scheme where an Interest is used to signal a
      name prefix that a consumer has registered for receiving
      Interests from a peer in a bidirectional streaming session.
      <!--
      <cref source="DO">I tried to find a
      reference for Interest-Interest-Data without success - any
      ideas?</cref> <cref
      source="DKU">https://ieeexplore.ieee.org/document/7119766
      probably - cannot access right now though</cref> -->
    </dd>
    <dt><strong>Peer state synchronization:</strong></dt>
    <dd>
      A large class of applications, typified by those built on top of
      reliable order-preserving transport protocols, require
      initial state synchronization between the peers. This is
      accomplished with a three-way (or longer) handshake, since
      employing a two-way handshake as provided in the existing NDN
      and CCNx protocols exposes a number of well-known hazards, such
      as <em>half-open connections</em>. When attempted for
      security-related operations such as key exchange, additional
      hazards such as <em>man-in-the-middle</em> attacks become
      trivial to mount. Existing alternatives, similar to those used
      in the two examples above, instead utilize either overlapping
      Interest-Data exchanges in opposite directions (resulting in a
      four-way handshake) or by adding initialization data to the
      initial request and employing an Interest-Interest-Data protocol
      extension as noted in the Phone-home scenarios above.
    </dd>
  </dl>
  <t>
    All of the above application interaction models present
    interesting challenges, as neither relaxing the architecture to
    support pushing large amounts of data, nor introducing substantial
    complexities through multiple independent Interest-Data exchanges
    is an attractive approach. The following subsections provide
    further background and justification for why push and/or
    independent exchanges are problematical.
  </t>

  <section anchor="push-problems"><name>Problems with pushing data</name>

  <t>
    There are two substantial problems with the simple approach of
    just allowing arbitrary amounts of data to be included with
    requests. These are:
  </t>
   <ol>
     <li>
       In ICN protocols such as NDN and CCNx, Interest messages are intended to be small,
       on the order the size of a TCP ACK, as opposed to the size of a
       TCP data segment. This is because the hop-by-hop congestion
       control and forwarder state management requires Interest
       messages to be buffered in expectation of returning data, and
       possibly retransmitted hop-by-hop as opposed to end-to-end. In
       addition, the need to create and manage state on a per-Interest
       basis is substantially complicated if requests in Interest
       messages are larger than a Path MTU (PMTU) and need to be
       fragmented hop-by-hop.
     </li>

     <li>
       If the payload data of a request is used for invoking a
       computation (as in the RMI case described above)
       then substantial bandwidth can be wasted if the computation is
       either refused or abandoned for any number of reasons,
       including the requestor failing an authorization check, or the
       responder not having sufficient resources to execute the
       associated computation.
     </li>
   </ol>

   <t>
     These problems also exist in pure datagram transport protocols
     such as those used for legacy RMI applications like <xref
     target="RFC7530">NFS</xref>. More usual are application protocols
     like HTTP(s) which rely on the TCP or QUIC 3-way handshake to
     establish a session and then have congestion control and
     segmentation provided as part of the transport protocol, further
     allowing sessions to be rejected before large amounts of data are
     transmitted or significant computational resources expended.
   </t>
  </section>

  <section anchor="independent-exchange-problems">
  <name>Problems with utilizing independent exchanges</name>
  <t>
    In order to either complete a three-way handshake, or fetch data
    via a pull from the original requestor, the role of consumer and
    producer need to be reversed and an Interest/Data exchange
    initiated in the direction opposite of the initiating
    exchange. When done with an independent Interest/Data request and
    response, a number of complications ensue. Among them are:
  </t>
  <ol>
    <li anchor="routable-name-prefix">
      The originating consumer needs to have a routable name prefix
      that can be used for the exchange. This means the consumer must
      arrange to have its name prefix propagated in the ICN routing system
      with sufficient reach that the producer issuing the interest can
      be assured it is routed appropriately. While some consumers are
      generally online and act as application servers, justifying the
      maintenance of this routing information, many do not. Further,
      in mobile environments, a pure consumer that does not need to
      have a routable name prefix can benefit from the inherent
      consumer mobility support in the CCNx and NDN protocols. By
      requiring a routable name prefix, extra mobile routing machinery
      is needed, such as that proposed in <xref
      target="Zhang2018">KITE</xref> or <xref
      target="Auge2018">MAPME</xref>.
    </li>

    <li anchor="reflection-attack">
      The consumer name prefix in <xref target="routable-name-prefix"
      format="counter">item</xref> above must be communicated to the
      producer as a payload, name suffix, or other field of the
      initiating Interest message. Since this name in its entirety is
      chosen by the consumer, it is highly problematic from a security
      standpoint, as it can recruit the producer to mount a reflection
      attack against the consumer's chosen victim.<!-- ' -->
    </li>

    <li>
      The correlation between the exchanges in opposite directions
      must be maintained by both the consumer and the producer as
      independent state, as opposed to being architecturally tied
      together as would be the case with a conventional 3-way
      handshake finite state machine. While this can of course be
      accomplished with care by both parties, experience has shown
      that it is error prone (for example see the checkered history of
      interactions between the <xref target="RFC3261">SIP</xref> and
      <xref target="RFC6337">SDP Offer-Answer</xref>) protocols. When employed
      as the wrapper for a key management protocol such as with <xref
      target="RFC8446">TLS</xref> state management errors can be
      catastrophic for security.
    </li>
  </ol>
  </section>
</section>

<section anchor="terminology"><name>Terminology</name>
	
	<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.</t>

	<section anchor="definitions"><name>Definitions</name>
	 <t>For general ICN-related terms, we adopt the terms defined in <xref target="RFC8793"/>. For CCNx-specific terms, we use the terms defined in <xref target="RFC8569"/> and <xref target="RFC8609"/>. This specification defines the following additional terms:</t>
	 <dl>
	 	<dt><strong>Reflexive Interest</strong> (RI)</dt><dd>An interest message sent from a producer back towards a consumer to fetch data needed to satisfy the original interest.</dd>
	 	<dt><strong>Reflexive Data</strong> (RD)</dt><dd>a Data message rteurned to a producer in response to a Reflexive Interest sent from the producer to the consumer</dd>
		<dt><strong>Trigger Interest</strong> (TI)</dt><dd>An interest message sent from a consumer to a producer to potentially trigger one or more Reflexive Interests sent by the producer back to the consumer.</dd>
		<dt><strong>Trigger Data</strong> (TD)</dt><dd>The data message returned by the producer in response to a Trigger Interest sent by the consumer, which completes a possibly multi-message Reflexive Forwarding exchange</dd>
	 	<dt><strong>Reflexive Name Segment</strong></dt><dd>A typed name segment which, when present as the initial (highest-order) name segment identifies an Interest as being a Reflexive Interest instead of a normal Interest.</dd>
	 	<dt><strong>Reflexive Name Prefix (RNP)</strong></dt><dd>A value carried in an Interest message to indicate to a producer that it may fetch data from the sending consumer by issuing one or more corresponding Reflexive Interests. It consists of a Name prefix whose high-order (i.e. first) name segment is a Reflexive Name Segment as defined above. It acts as a nonce, distinguishing Reflexive Interests related to a specific Trigger Interest from others in the same space-time vicinity of the network.</dd>
	 </dl>
	 <aside><t><strong>Note: </strong>the above definition may need to be adjusted depending on the decision about protocol encoding discussed in  <xref target="reflexive-name-prefix-in-trigger-interest"/>.</t></aside>
	</section>

</section>

<section anchor="design-overview"> 
<name>Overview of the Reflexive Forwarding design</name>

<t>
  This specification defines a <em>Reflexive Forwarding</em> extension
  to CCNx and NDN that avoids the problems enumerated in Sections
  <xref target="push-problems" format="counter"/> and <xref
  target="independent-exchange-problems" format="counter"/>. It
  straightforwardly exploits the hop-by-hop state and path symmetry
  properties of the current protocols.
</t>

<t>
  <xref target="forwarder-data-structures"/> below illustrates a
  canonical NDN/CCNx forwarder with its conceptual data structures of
  the Content Store (CS), Pending Interest Table (PIT) and Forwarding
  Information Base (FIB). The key observation involves the relation
  between the PIT and the FIB. Upon arrival of an Interest, a PIT
  entry is created which contains state recording the incoming
  interface on which the Interest was received. If the Interest is
  not immediately satisfied by cached data in the CS, the forwarder
  looks up the name in the FIB to ascertain the <em>next-hop</em> to
  propagate the Interest onward upstream toward the named
  producer. Therefore, a chain of forwarding state is established
  during Interest forwarding that couples the PIT entries of the chain
  of forwarders together conceptually as <em>breadcrumbs</em>. These
  are used to forward the returning Data Message over the reverse path
  through the chain of forwarders until the Data message arrives at
  the originating consumer. The state in the PITs is <em>unwound</em>
  by destroying it as each PIT entry is <em>satisfied</em>. This
  behavior is <strong>critical</strong> to the feasibility of the
  reflexive forwarding design we propose.
</t>

	<figure anchor="forwarder-data-structures">
		<name>ICN forwarder structure</name>
		<!-- <artwork type="svg" src="data-fwd-new-svgt.svg"/> -->
		<!-- <artwork type="svg" src="interest_fwr-svgt.svg"></artwork> -->
		<!-- <artwork type="svg" src="data_fwr-svgt.svg"></artwork> -->

		<artwork type="ascii-art">
 +-----------------------------------------------------------------+
 |                                                      ICN Node   |
 | Send data to all                                     ========   |
 | interfaces that                                                 |
 | requested it                                                    |
 |                  YES +------------------+                       |
&lt;-----------------------| Pending Interest |  &lt;---------------------
 |              |       |    Table (PIT)   |               Data    |
 |              |       +------------------+  1) Find     (Signed) |
 |              | 2) Save         |              Name              |
 |              V    Data         | NO            in               |
 |   +---------------+            |              PIT?              |
 |   | Content Store |            |                                |
 |   |      (CS)     |            |                                |
 |   +---------------+            |                                |
 |                                |                                |
 |                                V                                |
 |                             Drop Data                           |
 |                                                                 |
 +-----------------------------------------------------------------+
 		</artwork>

		<artwork type="ascii-art">
 +-----------------------------------------------------------------+
 |                                                      ICN Node   |
 |                                                      ========   |
 |                                                                 |
 |                                           +====================+|
 |                                           |Forwarding Strategy ||
 |                                           +====================+|
 |                                                                 |
 |   1) Find name          2) Matching        3) Find matching     |
 |        in CS?              name in PIT?       entry in FIB?     |
 |                    NO                   NO                   YES|
 |  +---------------+   +----------------+   +-------------------+ |
 |  | Content Store |   |   Pending      |   |  Forwarding       | |
--->|      (CS)     |-->|   Interest     |-->|  Information Base |-->
 |  |               |   |   Table (PIT)  |   |     ( FIB)        | |
 |  +---------------+   +----------------+   +-------------------+ |
 | Return   | YES           YES | NO               NO |            |
 |  Data    |          Add      |   Add               |  Drop      |
 |          |          Incoming |   new               |   or       |
 |   &lt;------+          Itf.     |   Interest          |  NACK      |
 |                              V                     V            |
 |                                                                 |
 +-----------------------------------------------------------------+
      		</artwork>

	</figure>


	<t>
	  Given the above forwarding properties for Interests, it
	  should be clear that while an Interest is outstanding and
	  ultimately arrives at a producer who can respond to it,
	  there is sufficient state in the chain of forwarders to
	  route not just a returning Data message, but potentially
	  another Interest directed through the reverse path to the
	  unique consumer who issued the original Interest. (<xref
	  target="interest-aggregation"/> describes how Interest
	  aggregation of requests to the same target name from multiple consumers
	  interacts with this scheme.) The key question
	  therefore is how to access this state in a way that it can
	  be used to forward Interests from the producer back to the consumer.
	</t>

	<t>
	  In order to achieve this <em>Reflexive Interest</em>
	  forwarding on the reverse path recorded in the PIT of each
	  forwarder, we need a few critical design elements: 
	</t>

	<ol>
	  <li>
	    The Reflexive Interest needs to have a <em>Name</em>. This name is
	    what the originating consumer will use to match against
	    the Data object (or multiple Data objects — more on this
	    later) that the producer may request by issuing the
	    Reflexive Interest. This cannot be just any name, but
	    needs to essentially name the state already recorded in
	    the PIT and not allow the consumer to manufacture an
	    arbitrary name and mount a reflection attack as pointed
	    out in <xref target="reflection-attack"/>.
	  </li>

	  <li anchor="interest-fwd-requirements">
	    Each forwarder along the reverse path from producer to
	    consumer must be able to forward the Reflexive Interest
	    towards the direction of the Consumer without relying
	    on global routing information, as the Reflexive
	    Name Prefixes are only valid while the originating Interest/Data exchange
	    state is present at the forwarders. Essential to this operation is the ability to
	    access state created by the PIT entry associated with the Trigger Interest message since that is the state necessary to identify the ingress face of the Trigger Interest. This is the unique output face (modulo interest aggregation)  over which the Reflexive Interest needs to be forwarded. The Name assigned by the
	    consumer for Reflexive Name Prefix in theory is adequate to the task, but entails a potentially expensive and complicated lookup procedure.
	  </li>

	  <li>
	    There has to be coupling of the state between the
	    originating Interest-Data exchange and the enclosed
	    Reflexive Interest-Data exchange at both the consumer and
	    the producer. In our design, this is accomplished by the
	    way Reflexive Interest names are chosen.
	  </li>
	</ol>
</section>

<section anchor="detailed-specification">
  <name>Detailed Specification of Reflexive Forwarding</name>
	<t>The following sections provide the normative details on each of these design elements.</t>
	 
	<section anchor="generic_spec"><name>Generic Forwarder Design</name>
	 
	<t>The following describes the operation of a CCNx or NDN forwarder enhanced to accommodate reflexive forwarding via Trigger Interests, Reflexive Interests, Reflexive Data and Trigger Data messages. This description likely adequate for most implementation approaches. However, there are possible performance bottlenecks for reflexive forwarding that employ highly parallel forwarding schemes using multi-core server systems. Such systems may use <em>PIT Sharding</em> across cores, and therefore benefit from additional optional protocol enhancements, such as the "PIT Token" protocol elements pioneered in <xref target="Shi2020"/>. Alternatively, techniques such as those employed by the Cefore <xref target="Asaeda2019"></xref><xref target="Cefore"></xref> forwarder from NICT may be employed.</t>

	<!--
	<t>The overall interaction flow for reflexive forwarding is illustrated below in <xref target="overall-message-flow"/>.</t>
	  	
	<figure anchor="overall-message-flow"><name>Overview of Message Flow</name>
	  <artwork type="ascii-art" src="message-flow-generic.txt"/>
	  <artwork type="ascii-art">
    Legend:
    TI1: Trigger Interest #1 containing the Reflexive Name Prefix TLV
    RI1: Reflexive Interest with Reflexive Name Prefix Segment
    RNP: Reflexive Name Prefix
    RD1: Data message, answering RI1
    TD1: Data message, answering TI1
	  </artwork>
	</figure>
	
	<t>The following sub-sections further describe reflexive forwarding operation for CCNx and NDN respectively.</t>
	-->
	</section>
	
	<section anchor="CCNx_spec">
	<name>Interaction Flow for Reflexive Forwarding: An Example</name>

	<t>Based on the implementation approach in Cefore <xref target="Asaeda2019"></xref><xref target="Cefore"></xref>, an example of the overall interaction flow for reflexive forwarding for CCNx is presented below and illustrated in <xref target="overall-message-flow-ccnx"/>. Other implementation approaches are of course equally valid as long as the protocol semantics are maintained.</t>

	<t>Forwarder operation for CCNx is enhanced in the following respects when supporting Reflexive Interests.</t>
	<ul>
		<li>When a forwarder receives a Trigger Interest (TI) that will be sent toward the producer, in addition to the normal PIT entry created on receipt of a new Interest message, the forwarder creates a <em>"template"</em> PIT entry (t-PIT) for the possible later receipt of a Reflexive Interest</li>
		<li> This template PIT entry has the Reflexive Name Prefix from the Trigger Interest as its Name field, and the incoming face list of the trigger interest as the potential output face(s) for any subsequent Reflexive Interest received.</li>
		<li>On receipt of a Reflexive Interest matching the Reflexive Name Prefix of a template PIT entry, a full PIT entry is created from the template entry and normal PIT processing ensues (e.g. also including recording the incoming face(s) of the Reflexive Interest).</li>
		<li>The Reflexive Interest is forwarded over the recorded outgoing face(s) from the PIT as opposed to examining the FIB to find an appropriate next hop for that Reflexive Interest.</li>
		<!--the name of the Name TLV in TI, downstream face (i.e., face from which the TI is received), and upstream face(s) (i.e., face(s) from which the TI is/are forwarded), and (2) a tentaive PIT entry for a Reflexive Interest (RI) (RI-PIT(dummy), hereafter) that includes Reflexive Name Prefix (RNP), downstream face (i.e., face(s) from which the TI is/are forwarded), and upstream face (i.e., face from which the TI is received). RI-PIT(dummy) is created whenever TI is received. However, RI-PIT(dummy) is not used for packet forwarding; it is only referred to create the actual PIT entry for RI (RI-PIT, hereafter). When a forwarder receives RI, it creates RI-PIT by copying the downstream and upstream faces from the RI-PIT(dummy) with the same RNP.</t> -->
	</ul>
	
	<figure anchor="overall-message-flow-ccnx">
	<name>Overview of Reflexive Forwarding in CCNx</name>
	<artwork type="ascii-art" src="message-flow-generic-ccnx.txt"/>
	<artwork type="ascii-art">
    Legend:
    TI: Trigger Interest containing Reflexive Name Prefix
    RI: Reflexive Interest with Reflexive Name Prefix
    RNP: Reflexive Name Prefix
    t-PIT: A template PIT entry created from the TI PIT entry
    RD: Data message, answering RI
    TD: Data message, answering TI
	  </artwork>
	</figure>

	<t>There are a number of reasons to maintain both a template RI-PIT and (possibly) multiple RI-PIT entries for reflexive forwarding. Among them are:</t>
	<ul>
	<li>There may be <xref target="I-D.irtf-icnrg-ccnxchunking">multiple chunks</xref>  requested using a sequence of Reflexive Interests.</li>
	<li>Multiple Reflexive Interests may be issued by the producer to fetch arguments in the remote invocation use case described in  <xref target="RMI"/>.</li>
	</ul>
	<t>This is further discussed in <xref target="multiple-reflexive-interests"/> on how to handle multiple reflexive interests sent in the context of a single Trigger Interest / Trigger Data interaction.</t>
	
	</section>
	
	<section anchor="naming"><name>Naming of Reflexive Interests</name>
	<t>
	A consumer may have one or more objects for the producer to
	fetch, and therefore needs to communicate enough information
	in its initial Trigger Interest to allow the producer to construct
	properly formed Reflexive Interest names. For some
	applications the set of <em>full names</em> (see <xref
	target="RFC8793">the ICN Terminology RFC</xref>) is known a priori, for
	example through compile time bindings of arguments in
	an interface definition or by the architectural definition of a
	simple sensor reading. In other cases, the full names of the
	individual objects must be communicated (or inferred) via the Reflexive Name Prefix (RNP) in the Trigger Interest message.
	</t>

	<t>
	We define a new name segment type, the <em>Reflexive Name Segment</em> which holds the <em>Reflexive Name Prefix</em> in Reflexive Interest and Reflexive Data messages. The Reflexive Name Segment MUST be the first (i.e. high order) name segment of any Reflexive Interest issued by a producer. In CCNx, the Reflexive Name Segment type value will be registered in the IANA registry for <xref target="RFC8609"/> when approved (see <xref target="IANA" />).</t>

	<t>	The value of any Reflexive Name Prefix is assigned by the consumer. The selected value MUST provide sufficient entropy to uniquely identify the issuing consumer for the duration of any outstanding Trigger Interest-Trigger Data exchange. Any scheme that provides sufficient randomness and entropy can suffice, but the consumer SHOULD choose a different random value for each Reflexive Name Prefix it constructs because:</t>
	
	<ol>
	  <li>A collision of Reflexive Name Prefixes
	  at any of the intermediate forwarders would result
	  in the same mutability 
	  problems generated by poor name selection in other contexts, such as
	  mis-routing of Reflexive Interests;
	  and</li>
	  
	  <li>Re-use of the same reflexive interest name over multiple
	  interactions might reveal linkability information that could
	  be used by surveillance adversaries for tracking purposes.</li>
	</ol>
	<t>A UUID, which is a randomly generated 128 bit quantity specified in <xref target="RFC9562"/>
	<!-- , or a hash value signed by the consumer's secret key (see <xref target="signed_RNP"/>) -->
	can be used for the value of the Reflexive Name Segment.</t>
	
	<t>
	This initial name segment in the Reflexive Interest is prepended to any object names the consumer wishes the producer to fetch.
	More than one object may be needed by the producer for the
	current Interest-Data interaction. There are three cases to consider:
	</t>
	<ol>
	  <li anchor="single-reflexive-object">
	    The reflexive <em>fullname</em> of a single object to fetch.
	  </li>
	  <li>
	    A single reflexive name prefix out of which the producer
	    can (by application-specific means) construct a number of
	    <em>fullnames</em> of the objects it may want to fetch.
	  </li>
	  <li>
	    The reflexive <em>fullname</em> of a <xref
	    target="I-D.irtf-icnrg-flic">FLIC Manifest</xref>
	    enumerating the suffixes that may be used by the producer
	    to construct the necessary names. We distinguish this from the single object fetch
	    in <xref target="single-reflexive-object" format="counter">case</xref> above because the use of a Manifest implies multiple Reflexive Interest/Data exchanges with the consumer. 
	  </li>
	</ol>
	
	<t>
	A producer, upon receiving a Trigger Interest with a
	Reflexive Name Prefix, may decide it needs to retrieve the
	associated data object(s). It therefore can issue one or
	more Reflexive Interests by appending the necessary name
	segments needed to form valid full names of the associated
	objects present at the originating consumer. These in fact
	comprise conventional Interest-Data exchanges, with no
	alteration of the usual semantics with regard to signatures,
	caching, expiration, etc. When the producer has retrieved
	the required objects to complete the original Interest-Data
	exchange, it can issue its Data response, which unwinds all
	the established state at the producer, the consumer, and the
	intermediate forwarders.
	</t>

	<section anchor="reflexive-name-prefix-in-trigger-interest">
	<name>How to represent/encode the Reflexive Name Prefix in the Trigger Interest</name>
	<t>While the design is firm on how to represent the Reflexive Name Prefix (RNP) in Reflexive Interests (and, by extension in the corresponding Reflexive Data response) by using a Reflexive Name Segment as the highedt-order name segment of the Reflexive Interest, we have studied two reasonable approaches to how the RNP should be represented in Trigger Interests. These are:</t>
	<ol>
		<li anchor="name-segment-for-TI">as a Reflexive Name Segment of the Trigger Interest Name. This is the same registered name segment type as used for Reflexive Interests, but present as the last (i.e. <em>trailing</em>) name segment.</li>
		<li anchor="separate-TLV-for-TI">as a separately defined and IANA registered message-level TLV in the Trigger Interest.</li>
	</ol>
	<t>There are tradeoffs in the choice of encoding. We outline the ones we are aware of below. Further experimentation with implementing the protocol and using it will inform a final decision on which approach to codify.</t>
	<aside><t><strong>Note: </strong>Approach <xref target="name-segment-for-TI"  format="counter"/> is currently the method implemented by the <xref target="Cefore">Cefore forwarder</xref></t></aside>
	
	<ul>
	  <li>Approach <xref target="name-segment-for-TI"  format="counter"/> likely limits the ability to make use of caching for Trigger Data responses. This is because no two TIs from different consumers would carry the same name - at least within the lifetime of the TI-TD pair. It is however unclear whether that is a significant problem. In many, perhaps most, applications where RI is needed (e.g., remote method invocation, access to paywalled content) the returned Trigger Data is unlikely to be usefully cacheable (e.g., because it is encrypted with a subscriber-specific key/watermark).</li>
	  
	  <li>Approach <xref target="separate-TLV-for-TI" format="counter"/> requires a separate check to avoid incorrect interest aggregation, since trigger interests with different RNP TLVs should not be aggregated. Approach <xref target="name-segment-for-TI"  format="counter"/> “just works” since the names are different and won’t be aggregated. However, this may be of little consequence since interest aggregation checks already require a forwarder to examine other optional Interest message fields such as <em>Interest Payload</em>. See <xref target="RFC8609"/> Section 2.4.2 for more information.</li>
	  
	  <li>Approach <xref target="name-segment-for-TI"  format="counter"/> doesn’t have to echo back the value in the finishing Trigger Data response, making it smaller. That might matter a bit in the sensor phone-home use case (<xref target="phone-home"/>), but it’s likely not a big deal given that RNPs allocated according to the UUID scheme are only 128 bits and hence unlikely to make that much of a difference.</li>
	</ul>
	
	</section>
	
	<section anchor="multiple-reflexive-interests"><name>Naming of multiple Reflexive Interests</name>
	<t> As noted in the general description of <xref target="CCNx_spec"/>, a given use case may require multiple RI/RD exchanges within the scope of a single TI/TD exchange.</t>
	<t>One example is an object to be returned via reflexive data that requires multiple chunks. Following are some examples of the names without/with chunk information enclosed in TI and RIs:</t>
	<figure><name>Responses without/with multiple chunks using Reflexive Interests</name>
	<artwork align="left"><![CDATA[
TI: ccnx:/Name=example.com/RNP=RNP1
RI: ccnx:/RNP=RNP1

TI: ccnx:/Name=example.com/RNP=RNP1
RI_1: ccnx:/RNP=RNP1/Chunk=0  ---
RI_2: ccnx:/RNP=RNP1/Chunk=1  EndChunkNumber=2
RI_3: ccnx:/RNP=RNP1/Chunk=2  EndChunkNumber=2
	]]></artwork>
    </figure>
	
	<t>The RI-PIT entry MAY include a chunk number to the RNP, while a template RI-PIT entry does not. Like an ordinary PIT entry, RI-PIT is erased whenever the corresponding RD is forwarded through the downstream face, while a template RI-PIT entry is erased when the TI-PIT lifetime expires or Trigger Data (TD) is received and forwarded at the forwarder.</t>

		<aside><t><strong>Note: </strong>The above likely needs some adjustment when we sort out the general handling on chunking for both regular and reflexive interests. Stay tuned.</t></aside>
		
	<t>A second common use case is argument fetch for remote method invocation.</t>
	<aside><t><strong>Note: </strong>An example will be included in a later draft version</t></aside>
	
	</section>
	
	<section><name>Recursive Reflexive Interest invocation</name>
		<t>There is no explicit prohibition in this version of the specification to use a Reflexive Interest as a Trigger Interest to recursively create a multi-way handshake protocol. It is not yet clear if there are any compelling use cases for this or if there are undiscovered hazards by permitting it. However, we are confident that we do have sufficient protections against resource depletion attacks that could be attempted through this technique.</t>
	</section>
	
<!-->	<section anchor="signed_RNP"><name>Signed RNP</name>
		<t>Signed RNP validates that it is the name signed by the consumer's secret key. It does not only guarantee the uniqueness of RNP, but also provides the secure schema as it can be validated whether the RNP is securely created by the legitimate consumer. More detail explanation will be TODO.</t>
		
		<aside><t><strong>[HA]</strong>I will complete this section later.</t></aside>		

		<aside><t><strong>[DO]</strong>signed stuff in Interests inflates interest message size, which is a major thing we are trying to avoid by inventing reflexive forwarding. also...</t></aside>

		<aside><t><strong>[DO]</strong>Doesn't this require that the producer have the consumer's public key in its possession? In fact, how does it figure out who the consumer is in the first place? An important use case for reflexive forwarding in the first place is to use RI/RD exchanges to do key bootstrapping. If the producer already has the consumer's public key why bother with the reflexive exchange in the first place?</t></aside>

		</section> -->
	</section>

	<section anchor="consumer-operation"><name>Consumer Operation</name>
	<t>
	A consumer wishing to employ Reflexive Forwarding MUST include a Reflexive Name Prefix (RNP) in the Interest, which causes it to be treated as a Trigger Interest by Forwarders and Producers. The producer can subsequently craft Reflexive Interests with names using the RNP as a Reflexive Name Segment. Upon receiving a Reflexive Interest (e.g. RI in <xref target="overall-message-flow-ccnx"/>) from a producer in response to the Interest whose first name segment is the RNP supplied
	earlier, the consumer SHOULD perform a full name match against the object specified in the RI, and return that object to the producer in a conventional Data message,
	(e.g. RD in	<xref target="overall-message-flow-ccnx"/>).
	</t>
    
	</section>
      

	<section anchor="producer-operation"><name>Producer Operation</name>

	<t>A producer that has received an Trigger Interest with a Reflexive Name Prefix (RNP) keeps  the supplied RNP from the Trigger Interest for subsequent (optional, depending on application semantics) Reflexive Interest sending.</t>
	
	<t>When sending a Reflexive Interest back to the consumer, the
	producer MUST construct a corresponding Interest name based on
	the RNP in the reflexive Interest.</t>

	</section>
      
	<section anchor="forwarder-operation"><name>Forwarder Operation</name>

	<!-- Most of this (except CS considerations) was already described in bullets of 4.2.  Need to ensure that they are consistent. I made changes to try to make them more consistent - I think Step 3 is suppoesed to be about the "template" PIT entry. -->
	<t>The forwarder performs the following operations.</t>  
	<ol>
	<li>
	<t>Upon receiving an Interest containing a Reflexive Name Segment as its highest-order name segment, the Interest is interpreted as a Reflexive Interest. A forwarder MAY check its CS for a matching Data Object. If a match is found, the corresponding Data is returned and the Reflexive Interest is considered satisfied. If no match is found, proceed with the following steps.</t>

<!-->	<t><strong>[HA]</strong> If Trigger Data is cached in CS, the next Trigger Interest whose name is the same of the previous one may not reach to the producer, and hence the producer cannot send Reflexive Interest to make the consumer push the data. It is not a wrong behavior because caching the TD implies that the pushed data (RD) was previously sent to the producer and it is not necessary to send the same RD to the producer again. However, it may be an unexpected behavior for the consumer because the consumer cannot push the data to the publisher until the caches in the network are perfectly expired/removed. This explanation (attention) must be clearly mentioned here or some place.</t>
-->

	<t><strong>Note:</strong> Given that reflexive interests initiate exchanges constrained by the Interest Lifetime of the enclosing Trigger Interest/Data exchange, the value of caching the Reflexive Data responses in forwarders is for short-term recovery from lost packets as opposed to optimizing longer term caching gain. For this reason we avoid mandating or strongly recommending the CS check for reflexive interests.</t>
	</li>
<!-- Think this is covered by the steps below.
	<li>
	The forwarder then MUST record the RNP as an element of the PIT entry for that Interest.
	</li>
	-->

	<li>
	The forwarder MUST check for the existence of a matching template PIT entry (i.e., one containing the RNP in this Interest's Name). If no matching template PIT entry is found, it could, strictly speaking, be considered an error, but the forwarder SHOULD simply process the Interest as a normal
	non-reflexive Interest and skip the steps below. A match
	indicates that this is a Reflexive Interest corresponding to
	the original Trigger Interest, so execute the following steps.
	</li>
	  	
	<li>
	Create a new PIT entry for the Reflexive Interest (if
	resources are sufficient). In the case of <xref target="Cefore"/> this is accomplished by cloning the new PIT entry from the template PIT entry created  earlier by receipt of the Trigger Interest.	 (For interactions with	Interest aggregation, also see <xref target="interest-aggregation"/>)
<!--	Also, regarding NDN, see <xref target="PIT-sharding"/> for how PIT shard interacts with
	the location and creation of PIT entries on high-speed forwarders. -->
	</li>
	  	
<!-->	<li>
	Record the Forward PIT-Token (FPT), if any, in this PIT entry, as would
	be done for any received Interest containing an FPT TLV.
	</li> -->
	  	
	<li>
	Look up the ingress face from the originating Trigger Interest's PIT
	entry, and forward the Reflexive Interest on this face. In the case of <xref target="Cefore"/> the face to forward on would have already been populated in the Reflexive Interest's PIT entry.
	</li>
	</ol>
    
	<t>
	The PIT entry for the Reflexive Interest is consumed per regular
	Interest/Data message forwarding requirements. The PIT entry for
	the originating Interest (that communicated the Reflexive
	Interest Name) is also consumed by a final Data message from the
	producer to the original consumer.
	<!-- dku: could say something about PIT entry expiry times and
	   more experimentation that should be conducted -->
	</t>

		<section anchor="forwarder-pseudocode">
		  <name>Forwarder algorithms in pseudocode</name>
		<t>This section provides some pseudocode examples to further explain the details of forwarder operation.
    	It has separate code paths for minimal forwarder operations and those needed by high-performance forwarders as is
    	further discussed in <xref target="PIT-sharding"/>.</t>
    	
	<section><name>Processing of a Trigger Interest containing a Reflexive Name Prefix</name>
		<sourcecode type="pseudocode">
Create PIT entry for Interest;
Optionally create a template PIT entry for any potential Reflexive Interests 
     expected to match the RNP in the Trigger Interest;
Forward Interest upstream;
			</sourcecode>
			</section>
    	
			<section><name>Processing of a Reflexive Interest</name>
			<sourcecode type="pseudocode">
Use Reflexive Name Segment of Reflexive Interest's Name to look up the Trigger Interest PIT entry;

IF PIT entry of original Interest not is found
    Issue an Interest Return with "No Route" error 
         back to the producer;
ELSE
    Create PIT entry for Reflexive Interest 
    (or optionally clone it from the template PIT entry that was created together 
     with the Trigger Interest PIT entry);
    Process as a normal Interest;
RETURN
			</sourcecode>
			</section>
		</section>
	</section>

	<section anchor="state-coupling"><name>State coupling between producer and consumer</name>

  <t>
    A consumer that wishes to use this scheme MUST utilize one of the
    reflexive naming options defined in <xref target='naming'/> and
    include it in the corresponding Interest message. The Reflexive
    Name Prefix <em>and</em> the full name of the requested data object
    (that identifies the producer) identify the common state shared by
    the consumer and the producer. When the producer responds by
    sending Interests with a Reflexive Name Prefix, the original
    consumer therefore has sufficient information to map these
    Interests to the ongoing Interest-Data exchange.</t>
	
    <t>
      The exchange is finished when the producer who received the
      Trigger Interest message responds with a Data message (or an
      Interest Return message in the case of error) answering the
      Trigger Interest. After sending this Data message, the producer
      SHOULD destroy the corresponding shared state.  It MAY decide to
      use a timer that will trigger a later state destruction. After
      receiving this Data message, the originating consumer MUST
      destroy the corresponding Interest-Data exchange state.</t>
	</section>

</section>
     
<section><name>Use cases for Reflexive Interests</name>
      
	<section anchor="RMI"><name>Achieving Remote Method Invocation with Reflexive Interests</name>

      <!--<t><strong>TBD.</strong> Recapitulate what RICE does... </t>-->

	<t>
	RICE (Remote Method Invocation in ICN) <xref
	target="Krol2018"/> used a similar Reflexive Interest Forwarding
	scheme that inspired the design specified in this document (similar to the original design captured in <xref target="fib-based-design"/>).
	</t>
	<t>
	In RICE, the original Interest denotes the remote method (plus
	potential parameters) to be invoked at a producer
	(server). Before committing any computing resources, the
	server can then request authentication credentials and
	(optional) parameters using reflexive Interest-Data exchanges.
	</t>
	<t>
	When the server has obtained the necessary credentials and
	input parameters, it can decide to commit computing
	resources, start the compute process, and return a handle
	("Thunk") in the final Data message to the original consumer
	(client).
	</t>
	<t>
	The client would later request the computation results using a
	regular Interest-Data exchange (outside the Reflexive-Interest
	transaction), using the Thunk as a name for the computation
	result.
	</t>
	<t>
	<xref target="rice-message-flow"/> depicts an abstract message
	diagram for RICE. In addition to the 4-way Reflexive
	Forwarding Handshake 
	<!--(see <xref target="overall-message-flow"/> -->
	for the details of the
	interaction, RICE adds another (standard) ICN Interest/Data
	exchange for transmitting the RMI result. The Thunk name is
	provided to the consumer in the D1 DATA message (answering the
	initial I1 Interest).
	</t>

	<figure anchor="rice-message-flow">
	<name>RICE Message Flow</name>
	<artwork type="ascii-art" src="rice2.txt"/>
	<artwork type="ascii-art">
    Legend:
    I1: Interest #1 containing the Reflexive Name Prefix TLV
    D1: Data message, answering initiating I1 Interest,
        returning Thunk name
    RI1: Reflexive Interest issued by producer
    RD1: Data message, answering RI (parameters, credentials)
    I2: Regular Interest for Thunk (compute result)
    D2: Data message, answering I2
	</artwork>
	</figure>
  
	</section>

	<section anchor="web"><name>RESTful Web Interactions</name>
      <t>
	In todays HTTP-based web, RESTful (Representational State
	Transfer) web interactions are realized by sending requests in
	a client/server interaction, where the requests provides the
	application context (or a reference to it). It has been noted
	in <xref target="Moiseenko2014"/> that corresponding requests
	often exceed the response messages in size, and that this
	raises the problems noted in <xref target="push-problems"/> 
	when attempting to map such exchanges directly to CCNx/NDN.
      </t>
      <t>
	Another reason not to include all request parameters in a
	(possibly encrypted) Interest message is the fact that a
	server (that is serving thousands of clients) would be obliged
	to receive, possibly decrypt and parse the complete requests
	before being able to determine whether the requestor is
	authorized, whether the request can be served etc. Many
	non-trivial requests could thus lead to computational overload
	attacks.
      </t>
      <t>
	Using Reflexive Interest Forwarding for RESTful Web
	Interactions would encode the REST request in the original
	request, together with a Reflexive Interest Prefix that the
	server could then use to get back to the client for
	authentication credentials and request parameters, such as
	cookies. The request result (response message) could either be
	transmitted in the Data message answering the original
	request, or — in case of dynamic, longer-running computations
	— in a seperate Interest/Data exchange, potentially
	leveraging the Thunk scheme described in <xref
	target="RMI" format="default"/>.
      </t>
      <t>
	Unlike approaches where clients have to signal a globally
	routable prefix to the network, this approach would not
	require the client (original consumer) to expose its identity
	to the network (the network only sees the temporary Reflexive
	Name Prefix), but it would still be possible to
	authenticate the client at the server.</t>
	
	<t>An initial design for achieving RESTful ICN that employs reflexive forwarding is presented in <xref target="Kutscher2022"/>.</t>
      
	</section>
	
	<section anchor="phone-home">
	<name>Achieving simple data pull from consumers with reflexive Interests</name>
      	
      <t>
	An oft-cited use case for ICN network architectures is
	<em>Internet of Things</em> (IoT), where the sources of data
	are limited-resource sensor/actuators. Many approaches have
	been tried (e.g. <xref target="Baccelli2014"/>, <xref
	target="Lindgren2016"/>, <xref target="Gundogan2018"/>) with
	varying degrees of success in addressing the issues outlined
	in <xref target="push-problems"/>. The reflexive forwarding
	extension may substantially ameliorate the documented
	difficulties by allowing a different model for the basic
	interaction of sensors with the ICN network.
      </t>
		
      <t>
	Instead of simply acting as a producer (either directly to the
	Internet or indirectly through the use of some form of
	application-layer gateway), the IoT device need only act as a
	consumer to initiate commuhication. When it has data to provide, it issues a
	"phone-home" Trigger Interest message to a pre-configured (or discovered) rendezvous
	name (e.g. an application-layer gateway or ICN <xref
	target="Chen2015">Repo</xref>) and provides a reflexive name
	prefix for the data it wishes to publish. The target
	producer may then issue the necessary Reflexive Interest
	message(s) to fetch the data. Once fetched, validated, and
	stored, the producer then responds to the Trigger Interest
	message with a success indication, possibly containing a Data
	object if needed to allow the originating device to modify its
	internal state. Alternatively, the producer might choose to
	not respond and allow the Trigger Interest to time out,
	although this is NOT RECOMMENDED except in cases where the
	extra message transmission bandwith is at a premium compared
	to the persistence of stale state in the forwarders. We note
	that this interaction approach mirrors the earlier efforts using
	Interest-Interest-Data designs.
      </t>

      <t>
	<xref target="phonehome-message-flow"/> depicts this
	interaction with the (optional) TD message.
	<!-- See <xref target="overall-message-flow"/> for the details of the general Reflexive Forwarding interaction.-->
      </t>
      
      <figure anchor="phonehome-message-flow">
	<name>"Phone Home" Message Flow</name>
	<artwork type="ascii-art" src="phonehome.txt"/>
	<artwork type="ascii-art">
    Legend:
    TI: Trigger Interest containing the Reflexive Name Prefix
    RI1: Reflexive Interest requesting the IoT data
    RD1: Data message, answering RI, returning IoT data object
    TD: (optional) Data answering I1
	</artwork>
      </figure>

      <t>
	There are two approaches that the IoT device can use for
	its response to a Reflexive Interest. It can simply construct
	a Data Message bound through the usual ICN hash name to the
	Reflexive Interest name. Since the scope of any data object
	bound in this way is only the duration of the enclosing
	Interest-Data exchange (see <xref
	target="consumer-implementation"/>) the producer would need to
	itself construct any persistent Data object, name it, and sign
	it. This is sometimes the right approach, as for some
	applications the identity of the originating IoT device is not
	important from an operational or security point of view; in
	contrast the identity of the gateway or Repo is what matters.
      </t>
		
      <t>
	If alternatively, the persistent Data object should be bound
	from a naming and security point of view to the originating
	IoT device, this can be easily accomplished. Instead of
	directly placing the content in a Data object responding to
	the reflexive Interest as above, the consumer encapsulates a
	complete CCNx/NDN Data message (which includes the desired name
	of the data) in the response to the Reflexive Interest
	message.
<!--
	<cref source="DO" display="false">
	  We may need to think if this exacerbates poisoning/pollution
	  attacks - I think not but need to noodle on this a bit.
	</cref>
-->
      </t>
      <t>
	The interaction model described above brings a number
	potential advantages, some obvious, some less so. We enumerate
	a few of them as follows:
      </t>
		
      <ul>
	<li>
	  By not requiring the IoT device to be actively listening for
	  Interests, it can sleep and only wake up if it has something
	  to communicate. Conversely, parties interested in obtaining
	  data from the device do not need to be constantly polling in
	  order to ascertain if there is new data available.
	</li>
	
	<li>
	  No forwarder resources are tied up with state apart from the
	  actual reflexive forwarding interactions. All that is needed
	  is enough routing state in the FIB to be able to forward the
	  "phone home" Interest to an appropriate target
	  producer. While this model does not provide all the richness
	  of a full Pub/Sub system (like that described in <xref
	  target="Gundogan2018"/>) we argue it is adequate for a large
	  subclass of such applications.
	</li>
			
	<li>
	  The Reflexive interest, through either a name suffix or
	  Interest payload, can give the IoT device useful context
	  from which to craft its Data object in response. One highly
	  useful parameter would be a robust clock value for the
	  device to use as a timestamp of the data, possibly as part
	  of its name, to correctly place it in a time seres of sensor
	  readings. This substantially alleviates the need for low-end
	  devices to have a robust time base, as long as they trust
	  the producer they contact to provide it.
	</li>
      </ul>
      
	</section>

    <!--
      <section anchor="state-synchronization"><name>Achieving peer state synchronization with Reflexive Interests</name>
      <t><cref source="DO"><strong>TBD.</strong> Talk about peer session establishment,
	Authz, key exchange, perhaps other use cases?</cref></t>
      </section>
-->
</section>

<section anchor="implementation-considerations">
	<name>Implementation Considerations</name>

	<t>There are a number of important aspects to the reflexive
	  forwarding design which affect correctness and performance
	  of existing forwarder, consumer, and producer
	  implementations desiring to support it. This section
	  discusses the effect of each of these elements on the
	  protocol architecture.</t>

	<section anchor="forwarder-implementation">
	<name>Forwarder implementation considerations</name>

	<section>
	<name>Interactions with Input Processing of Interest and Data packets</name>
       <t>Reflexive Interests are designed specifically to be no
      	    different from any other Interest other than the use of
      	    the Reflexive Name Segment type as their
      	    high-order name segment. This means that a forwarder
      	    does not have to have special handling in terms of
      	    creation, and destruction, and other Interest processing
      	    needs such as timeouts, Interest satisfaction, and caching
      	    of returning data in the CS if desired. However, this
      	    design does require additional processing for Reflexive
      	    Interests not needed in the absence of reflexive
      	    forwarding. The most significant requirements are:</t>
    	<ul>
      	<li>In order to locate the matching RNP from the Trigger Interest, the forwarder's packet input processing needs to be able to efficiently access a PIT entry storing the RNP of the corresponding Trigger Interest.</li>
      	
      	<li>Ensure that the highest order name segment of the Reflexive
	    Interest is a Reflexive Name Segment that matches the RNP stored in that PIT entry.</li>
      	</ul>
      	
    	<t>There are a few additional considerations to highlight for
    	high-speed forwarders however; these are discussed in the
    	following paragraphs.</t>
 	
      	<t anchor="PIT-sharding">In order to achieve forwarding scalability, high speed
      	forwarders need to exploit available parallelism in both CPU
      	(through multiple cores) and memory (through multiport DRAM)
      	and limiting accesses to both DRAM and L3 caches). One
      	commonly-used technique is <em>PIT sharding</em>, where the
      	forwarder-global PIT is partitoned among cores such that all
      	processing of both Interest and Data for a given Name is
      	directed at the same core, optimizing both L1 I-cache
      	utilization and L2/L3/DRAM throughput and latency. This is
      	achieved in a number of implementations (e.g. <xref
      	target="So2013"/>) by hashing the fullname in the Interest or
      	Data and using that hash to select the assigned processing
      	core (and associated memory banks). This efficiently
      	distributes the load and minimizes the number of memory
      	accesses other than to bytes of the input packet.</t>
      	
      	<t>Straightforward input name hashing to achieve a sharded PIT
      	has one potentially undesirable side effect: the Trigger
      	Interest containing the Reflexive Name Prefix and any
      	resultant Reflexive Interests issued by the producer will likely hash
      	to different PIT shards, making any pointers that need to be
      	traversed across shards or cross-shard updates expensive,
      	possibly dramatically so. One could either optimize those
      	accesses (as, for example, suggested in the discussion of
      	Interest Lifetime in <xref target="interest-lifetime"/>) or
      	add special input handling of reflexive interests to steer
      	them to the same shard as the original interest. 
      	<!-- This latter
      	technique is what we have specified by making the use of PIT
      	Tokens similar to those in <xref target="Shi2020"/> an
      	important element of the design. -->
      	</t>

		</section>
      	
		<section anchor="interest-lifetime"><name>Interactions with Interest Lifetime</name>
      	      	
      		<t>If and when a producer decides to fetch data from
      		the consumer using one or more reflexive Interest-Data
      		exchanges, the total latency for the original
      		Interest-Data exchange is inflated, potentially by
      		multiple RTTs. It is difficult for a consumer to
      		predict the inflation factor when issuing the Trigger
      		Interest, and hence there can be a substantial hazard
      		of that Interest lifetime expiring before completion
      		of the full multi-way exchange. This can result in
      		persistent failures, which is obviously highly
      		undesirable.</t>
      	
      		<t>There is a fairly straightforward technique that
      		can be employed by forwarders to avoid these "false"
      		Interest lifetime expirations. In the absence of a
      		superior alternative technique, it is RECOMMENDED that
      		all forwarders implement the following algorithm.</t>
     	      	
      		<t>If and when a Reflexive Interest arrives matching
      		the Trigger Interest's RNP, the forwarder examines the
      		Interest lifetime of the arriving Reflexive
      		Interest. Call this value <em>IL<sub>r</sub></em>. The
      		forwarder computes MAX(<em>IL<sub>t</sub>,
      		(IL<sub>r</sub> * 1.5)</em>), and replaces
      		<em>IL<sub>t</sub></em> with this value. This in
      		effect ensures that the remaining Interest lifetime of
      		the Trigger Interest accounts for the additional 1.5
      		RTTs that may occur as a result of the Reflexive
      		Interest-Data exchange.</t>
      		
		<aside><t>We note that this is not unduly
		expensive in this design where the two PIT
		entries are guaranteed to be in the same PIT
		shard on a high speed forwarder. The earlier
		design discussed in <xref
		target="FIB-and-interest-lifetime"/> required
		some additional gymnastics.</t></aside>
      		
      		<t anchor="reflexive-producer-hazard">While the above
      		approach of inflating the interest lifetime of the
      		Trigger Interest to accommodate the additional RTTs
      		of reflexive Interest-Data exchanges avoids the
      		timeout problem, this does introduce a new
      		vulnerability that must be dealt with. A Producer,
      		either through a bug or malicious intent, could keep
      		an originating Interest-Data exchange alive by
      		continuing to send reflexive Interests back to the
      		consumer, while the consumer had no way to terminate
      		the enclosing interaction (there is no "cancel
      		Interest" function in either NDN nor CCNx). To
      		eliminate this hazard, if the consumer rejects a
      		Reflexive Interest with a T_RETURN_PROHIBITED error,
      		the forwarder(s), in addition to satisfying the
      		corresponding PIT entry, MUST also delete the
      		RNP from the Trigger Interest's PIT entry, thereby preventing any
      		further Reflexive Interests from reaching the
      		consumer. This in turn allows the enclosing Interest-Data
      		exchange to either time out or be correctly ended with
      		a Data message or Interest Return from the
      		Producer.</t>
      		
		</section>
	  
		<section anchor="interest-aggregation">
		<name>Interactions with Interest aggregation and multi-path/multi-destination forwarding</name>

      	<t>As with numerous other situations where multiple Interests
      	for the same named object arrive containing different
      	parameters (e.g. Interest Lifetime, QoS, payload hash) the
      	same phenomenon occurs for the Reflexive Name Prefix. If
      	Trigger Interests with different Reflexive Name Prefixes collide,
      	the forwarder MUST NOT aggregate these Interest messages and
      	instead MUST create a separate PIT entry for each.</t>
      	
      	<t>Forwarders supporting multi-path forwarding may of course
      	exploit this capability for Trigger Interests with identical Reflexive
      	Name Prefixes, like any other Interests. There are two
      	sub-cases of multi-next hop behavior; regular multi-path
      	(where the split traffic reconverges further upstream) and
      	multi-destination (where it doesn't and the Interest reaches
      	multiple producers).</t>

	<t>For multi-path, since the Interests that converge upstream
	carry identical Reflexive Name Prefixes, they will get
	aggregated. The forwarder might, just as for any other
	Interest, decide to either do single or multi-path forwarding
	of that Interest. If sent multi-path in parallel,
	these also will reconverge on the reverse path and get
	aggregated.</t>

	<t>For multi-destination, Reflexive Interests might get issued
	by multiple producers, but they will carry the same Reflexive
	Name Segment and hence be forwarded using the ingress face of the same
	Trigger Interest PIT entry until reaching the join point, at which they will get
	aggregated and thus handled identically to any other
	Interest(s) subject to aggregation.</t>

		</section>
	</section>

	<section anchor="consumer-implementation">
	<name>Consumer Implementation Considerations</name>
    	
		<section><name>Data objects returned by the consumer to reflexive name Interests arriving from a producer</name>
    	
    	<t>The Data objects returned to the producer in response to a
    	Reflexive Interest are normal CCNx/NDN data objects. The object returned
    	in response to a Reflexive Interest is named with its hash as the trailing
    	segment of the Reflexive Interest Name, and hence the scope
    	of the object is under most circumstances meaningful only for
    	the duration of the enclosing Interest-Data interaction. This
    	property is ideal for naming and securing data that is "part
    	of" the enclosing interaction — things like method arguments,
    	authenticators, and key exchange parameters, but not for the
    	creation and naming of objects intended to survive outside the
    	current interaction's scope (c.f. <xref target="phone-home"/>,
    	which describes how to provide globally-named objects using
    	encapsulation). In general, the consumer should use the
    	following guidelines in creating Data messages in response to
    	Reflexive Interest messages from the producer.</t>
    		
    		<ol type="(%c)">
    			<li>Set the recommended cache time (T_CACHETIME) either to zero, or a value no greater than the Interest lifetime (T_INTLIFE) of the Trigger Interest message.</li>
    			<li>Set the payload type (T_PAYLDTYPE) according to the type of object being returned (e.g. object, link, manifest)</li>
    			<li>Set the expiry time (T_EXPIRY) to a value greater than <em>now</em>, and less than or equal to the <em>now</em> + Interest lifetime (T_INTLIFE) of the original Interest message.</li>
    		</ol>
    		
		</section>
    	
		<section><name>Terminating unwanted reflexive Interest exchanges</name>
		<t>A consumer may wish to stop receiving Reflexive Interests due to possible errors or malicious behavior on the part of the producer. Therefore, if the consumer receives an unwanted Reflexive Interest, it SHOULD reject that interest with a T_RETURN_PROHIBITED error (See section 10.3.6 of <xref target="RFC8609"/> ). This will provoke the forwarders to prevent further reflexive Interests from reaching the consumer, as described above in <xref target="reflexive-producer-hazard"/>.</t>
		</section>
    	
		<section><name>Interactions with caching</name>
		<t>
	  The reflexive named objects provide "local", temporary names
	  that are only defined for one specific interaction between a
	  consumer and a producer. Corresponding Data objects MUST NOT
	  be shared among multiple consumers (violating this would require special gyrations by the producer since the reflexive Name utilizes per-consumer/per-interaction unique values generated randomly as described in <xref target="naming"/>). A producer MUST NOT issue an Interest message for any reflexive name after it has sent the final Data message answering the original Interest.
		</t>
		<t>
	  Forwarders MAY still cache reflexive Data objects for
	  retransmissions within a transactions, but they MUST invalidate or remove
	  them from the content store when they forward the final Data
	  message answering the Trigger Interest.
	  </t>
		</section>
	</section>
      
	<section anchor="producer-implementation">
	<name>Producer Implementation Considerations</name>
	<t>Producers receiving an Interest with a Reflexive Name
	Segment, MAY decide to issue Reflexive Interests for the corresponding
	Data objects. All Reflexive Interest messages that a producer
	sends MUST be sent over the face that the Trigger Interest
	was received on. </t>

	</section>
</section>

<section anchor="Ops"><name>Operational Considerations</name>
	
	<t>Reflexive forwarding represents a substantial enhancement to the
	CCNx/NDN protocol architecture and hence has important forward
	and backward compatibility consequences. The most important of
	these is that correct operation of the scheme requires an
	unbroken chain of forwarders between the consumer and the
	desired producer that support Reflexive Name Prefixes and the
	corresponding forwarder capabilities specified in <xref
	target="forwarder-operation"/>. When this invariant is not
	satisfied, some means is necessary to detect and hopefully
	recover from the error. We have identified three possible
	approaches to handling the lack of universal deployment of
	forwarders supporting the reflexive forwarding scheme.</t>
	
	<t>The first approach simply lets the producer detect the
	error by getting a "no route to destination" error when trying
	to send an Interest to a reflexive name. This will catch the
	error, but only after forwarding resources are tied up and the
	producer has done some work on the Trigger Interest
	message. Further, the producer would need a bit of smarts to
	determine that this is a permanent error and not a transient error
	to be retried. In order for the consumer to attempt recovery,
	there might be a need for some explicit error returned for the
	Trigger interest to tell the consumer what the likely problem
	is. This approach does not enable an obvious recovery path for
	the consumer either, since if the producer cannot easily detect the error, 
	the consumer has no way to know if a retry has any chance of succeeding.</t>
	
	<t>A second approach is to bump the CCNx/NDN protocol version
	to explicitly indicate the lack of compatability. Such
	Interests would be rejected by forwarders not supporting these
	protocol extensions. A consumer wishing to use Reflexive
	Name Prefixes would use the higher protocol version on those
	Interest messages (but could of course continue to use the
	current version number on other Interest messages). This is a
	big hammer, but may be called for in this situation
	because:</t>
	<ol type="(%c)">
		<li>it detects the problem immediately and
		deterministically, and</li>
		<li>one could assume an ICN routing protocol that
		would only forward to a next hop that supports the
		updated protocol version number. The supported
		forwarder protocol versions would have been
		communicated in the routing protocol ahead of
		time.</li>
	</ol>
	
	<t>A third option is to, as a precondition to utilizing the
	protocol in a deployment, create and deploy a neighbor
	capability exchange protocol which will tell a downstream
	forwarder if the upstream can handle the new protocol elements. This might
	avoid the large hammer of updating the protocol version, but
	of course this puts a pretty strong dependency on somebody
	actually designing and publishing such a protocol! On the
	other hand, a neighbor capability exchange protocol for
	CCNx/NDN would have a number of other substantial benefits,
	which makes it worth seriously considering anyway.</t>
	
</section>

<section anchor="encoding"><name>Mapping to CCNx and NDN packet encodings</name>

	<section anchor="CCNx-encoding"><name>Packet encoding for CCNx</name>
	<t keepWithNext="true">For CCNx <xref target="RFC8609"/>, this specification defines one new Name Segment type for the Reflexive Name Prefix.</t>
	<table><name>Reflexive Name Segment</name>
	<thead>
		<tr>
	  		<th align="center">Abbrev</th>
	  		<th align="center">Name</th>
			<th align="center">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
	  		<td>T_REFLEXIVE_NAME</td>
	  		<td>Reflexive Name Segment</td>
			<td>Name segment to use as name prefix in Reflexive Interest Messages</td>
		</tr>
	</tbody>
	</table>

	<figure anchor="reflexive-name-encoding"><name>Reflexive Name Prefix</name>
	<artwork align="center"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|   Type (=T_REFLEXIVE_NAME)    |             Length            |
+---------------+---------------+---------------+---------------+
/                     Reflexive Name Prefix                     /
+---------------+---------------+---------------+---------------+
]]></artwork>
	</figure>

	<dl>
	   <dt><strong>Type:</strong></dt>
	   <dd>Format of the Value field. For the Reflexive Name Segment, the type value MUST be T_REFLEXIVE_NAME in the current specification. 16 bit length.</dd>

	   <dt><strong>Length:</strong></dt>
	   <dd>Length of Value field in octets. 16 bit length.</dd>

	   <dt><strong>Reflexive Name Prefix</strong></dt>
	   <dd>Reflexive Name Prefix (RNP) assigned by consumer. Variable length.</dd>
	</dl>

	<t>For Trigger Interests, if approach <xref target="separate-TLV-for-TI" format="counter"/> from <xref target="reflexive-name-prefix-in-trigger-interest"/> is chosen, then a second registered type is needed. The same format as used above for the Name Segment Type will be registered by IANA as an Interest Message TLV.</t>
	
	<table><name>Reflexive Name Prefix TLV</name>
	<thead>
		<tr>
	  		<th align="center">Abbrev</th>
	  		<th align="center">Name</th>
			<th align="center">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
	  		<td>T_REFLEXIVE_NAME_PREFIX</td>
	  		<td>Reflexive Name Prefix TLV</td>
			<td>Interest message field to use as name prefix in Trigger Interest Messages</td>
		</tr>
	</tbody>
	</table>

	
	</section>
    
	<section anchor="NDN-encoding"><name>Packet encoding for NDN</name>
	<t><strong>These are proposed assignments based on <xref target="NDNTLV"/>. Suggestions from the NDN team would be greatly appreciated.</strong></t>
      
		<section><name>Reflexive Name Component Type</name>
        	  	<t>The NDN Name component TLVs needs to have a new component type added with type RNP (for reflexive name prefix). We suggest something like: <strong>TBD</strong></t>
        	  	<aside><t><strong>Note:</strong>It seems like the current 0.2.1 packet format only has allocated two name component types — a <em>GenericNameComponent</em> and a <em>ImplicitSha256DigestComponent</em>. Shouldn't there be more types by now or is this spec out of date?</t></aside>
		</section>
          	
		<section><name>Reflexive Name Prefix TLV</name>
			<t>For Trigger Interests, if approach <xref target="separate-TLV-for-TI" format="counter"/> from <xref target="reflexive-name-prefix-in-trigger-interest"/> is chosen, The Reflexive Name Prefix TLV needs to be added to the NDN Interest packet format. We suggest using <xref target="RFC9562"/>, hence something like:</t>
	      
			<table><name>Proposed Reflexive Name Prefix TLV for NDN Interest Packet</name>
			<tbody>
			<tr>
				<td>RNP ::=</td><td>RNP-TYPE</td><td>TLV-LENGTH(=16) BYTE8)</td>
			</tr>
			</tbody>
			</table>
			<aside><t><strong>[HA]</strong> CCNx adopts variable length for RNP. NDN as well?</t></aside>
		</section>
    
	</section>
</section>
    
<section anchor="IANA"><name>IANA Considerations</name>

	<t>As per <xref target="RFC8126" />, this section makes an assignment in two existing registries in the "Content-Centric Networking (CCNx)" registry group. The registration procedure is "RFC Required", which requires only that this document be published as an RFC.</t>

	<section anchor="sec.iana.name-segment" title="CCNx Name Segment Type Registry">
	<t>As shown in <xref target='CCNx-encoding' />, this document defines Name Segment type, T_REFLEXIVE_NAME, whose suggested value is %x0005.</t>
	</section>
	
	<section anchor="sec.iana.name-prefix-tlv" title="CCNx Validation-Dependent Data Types Registry">
	<t>As shown in <xref target='CCNx-encoding' />, this document defines one CCNx Validation-Dependent Data Type, T_REFLEXIVE_NAME, whose suggested value is %x0008.</t>
	
	</section>


</section>
    
<section anchor="Security" title="Security Considerations">
      
<!--
        <t><cref source="DO"><strong>Possibly also talk about</strong>stuff from RICE on avoiding server overload.</cref></t>
-->
      	
      <t>One of the major motivations for the reflexive forwarding
      extension specified in this document is in fact to enable better
      security and privacy characteristics for ICN networks. The main
      considerations are presented in <xref target="intro"/>, but we
      briefly recapitulate them here:</t>
      <ul>
      	<li>Current approaches to authentication and data transfer
      	often use payloads in Interest messages, which are clumsy to
      	secure (Interest messages must be signed) and as a consequence
      	make it very difficult to ensure consumer privacy. Reflexive
      	forwarding moves all sensitive data to the Data messages sent
      	in response to reflexive Interests, which are secured in the
      	same manner as all other Data messages in the CCNx and NDN
      	protocol designs.</li>
      	
      	<li>In many scenarios, consumers are forced to also act as
      	producers so that data may be fetched by either a particular,
      	or arbitrary other party. Therefore the consumer must arrange
      	to have a routable name prefix and that prefix be disseminated
      	by the routing protocol or other means. This represents both a
      	privacy hazard (by revealing possible important information
      	about the consumer) and a security concern as it opens up the
      	consumer to the full panoply of flooding and crafted Interest
      	Denial of Service attacks.</li>
      	
      	<li>In order to achieve multi-way handshakes, in current
      	designs a consumer wishing a producer to communicate back must
      	inform the producer of what (globally routable) name to
      	use. This gives the consumer a convenient means to mount a
      	variety of reflection attacks by recruiting the producer to
      	send Interests to desired victims.</li>
      </ul>
      
      <t>As a major protocol extension however, this design brings its
      own potential security issues, which are discussed in the
      following subsections.</t>
      
      <section><name>Collisions of reflexive Interest names</name>
      <t>Reflexive Interest names need to be constructed with sufficient randomness
      to ensure an off-path attacker cannot
      easily manufacture a matching reflexive Interest and either
      masquerade as the producer, or mount a denial of service attack
      on the consumer. Doing so also limits tracking through the linkability
      of Interests containing a re-used random value.</t>
      	
      <t>Therefore consumers MUST utilize a robust means of generating
      these random values, and it is RECOMMENDED that the <xref target="RFC9562"/> format
      be used, with a pseudo-random
      number generator (PRNG) approved for use with cryptographic
      protocols.</t>
      </section>
      
      <section><name>Additional resource pressure on PIT and FIB</name>
      <t>Normal Interest message processing in CCNx and NDN needs to
      consider effect of various resource depletion attacks on the
      PIT, particularly in the form of Interest flooding attacks (see
      <xref target="Gasti2012"/> for a good overview of DoS and DDoS
      mitigation on ICN networks). Interest messages utilizing this
      reflexive forwarding extension can place additional resource
      pressure on the PIT.</t>
      	
      <t>While this does not represent a new DoS/DDoS attack vector,
      the ability of a malicious consumer to utilize this extension in
      an attack does represent an increased risk of resource
      depletion, especially if such Interests are given unfair access
      to PIT and FIB resources. Implementers SHOULD therefore protect
      PIT and FIB resources by weighing requests for reflexive
      forwarding resources appropriately relative to other
      Interests.</t>
      </section> 
       
      <section><name>Privacy Considerations</name>
      <t>ICN architectures like CCNx and NDN provide a rich tapestry
      of interesting privacy issues, which have been extensively
      explored in the research literature. The fundamental tradeoffs
      for privacy concern the risk of exposing the names of
      information objects to the forwarding elements of the network,
      which is a necessary property of any name-based routing and
      forwarding design. Numerous approaches have been explored with
      varying degrees of success, such as onion routing (<xref
      target="DiBenedettoGTU12"/>), name encryption (<xref
      target="Ghali2017"/>), and name obfuscation (<xref
      target="Arianfar2011"/>) among others.</t>
      	
      	<t>Reflexive forwarding does not change the overall landscape
      	of privacy tradeoffs, nor seem to introduce additional
      	hazards. In fact, the privacy exposures are confined to the
      	reverse path of forwarders from the producer to the consumer,
      	through which the original Trigger Interest forwarding may have
      	already exposed names on path. Similar name privacy techniques
      	to those cited above may be equally applied to the names in
      	reflexive Interests.</t>
      	
      	<t>While the individual reflexive Interest-Data exchanges have
      	similar properties to those in any NDN or CCNx exchange, the
      	target usages by applications may have interaction patterns
      	that are subject to relatively straightforward fingerprinting
      	by adversaries. For example, a particular remote method invocation may
      	fingerprint simply through the count of arguments fetched by
      	the producer and their sizes. The attacker must however be on
      	path, which somewhat ameliorates the exposure hazards.</t>
      </section>
      
</section>
    
</middle>
  
  <back>
    
    <references><name>Normative References</name>
    <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
    <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
    <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8569.xml"/>
    <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
    <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8609.xml"/>

    </references>
      
    <references><name>Informative References</name>
	
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7530.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3261.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9562.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6337.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8793.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9531.xml"/>	
	<!--		<xi:include "reference.I-D.irtf.icnrg.mapme.xml"?> -->
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.irtf-icnrg-flic.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.irtf-icnrg-ccnxchunking.xml"/>
	
	<reference anchor="Krol2018" target="https://conferences.sigcomm.org/acm-icn/2018/proceedings/icn18-final9.pdf">
	  <front>
	    <title>RICE: Remote Method Invocation in ICN</title>
	    <author surname="Krol" initials="M."/>
	    <author surname="Habak" initials="K."/>
	    <author surname="Oran" initials="D."/>
	    <author surname="Kutscher" initials="D."/>
	    <author surname="Psaras" initials="I."/>
	    <date year="2018" month="September"/>
	  </front>
	  <seriesInfo name="Proc. the 5th ACM Conference on Information-Centric Networking" value="(ICN '18)"/>
	  <seriesInfo name="DOI" value="10.1145/3267955.3267956"/>
	</reference>

	<reference anchor="Shi2020" target="https://dl.acm.org/doi/10.1145/3405656.3418715">
		<front>
			<title>NDN-DPDK: NDN Forwarding at 100 Gbps on Commodity Hardware</title>
			<author surname="Shi" initials="J."/>
			<author surname="Pesavento" initials="D."/>
			<author surname="Benmohamed" initials="L."/>
			<date year="2020" month="September"/>
		</front>
		<seriesInfo name="Proc. the 7th ACM Conference on Information-Centric Networking" value="(ICN '20)"/>
		<seriesInfo name="DOI" value="10.1145/3405656.3418715"/>
	</reference>
		
	<reference anchor="NDN" target="https://named-data.net/project/execsummary/">
	  <front>
	    <title>Named Data Networking</title>
	    <author surname="NDN team"/>
	    <date year="2020"/>
	  </front>
	</reference>
	
	<reference anchor="NDNTLV" target="http://named-data.net/doc/ndn-tlv/">
    	  <front>
            <title>NDN Packet Format Specification</title>
	    <author surname="NDN Project Team"/>
	    <date year="2016" />
          </front>
    	</reference>
	
    	<reference anchor="Zhang2018" target="https://conferences.sigcomm.org/acm-icn/2018/proceedings/icn18-final23.pdf">
    	  <front>
    	    <title>KITE: Producer Mobility Support in Named Data Networking</title>
    	    <author surname="Zhang" initials="Y" fullname="Yu Zhang"/>
    	    <author surname="Xia" initials="Z." fullname="Zhongda Xia"/>
    	    <author surname="Mastorakis" initials="S." fullname="Spyridon Mastorakis"/>
    	    <author surname="Zhang" initials="L" fullname="Lixia Zhang"/>
    	    <date year="2018" month="September"/>
    	  </front>
		  <seriesInfo name="Proc. the 5th ACM Conference on Information-Centric Networking" value="(ICN '18)"/>
    	  <seriesInfo name="DOI" value="10.1145/3267955.3267959"/>
    	</reference>
	
	<reference anchor="Auge2018" target="https://ieeexplore.ieee.org/document/8267132">
	  <front>
	    <title>MAP-Me: Managing Anchor-Less Producer Mobility in Content-Centric Networks</title>
	    <author surname="Augé" initials="J." fullname="Jordan Augé" asciiSurname="Auge" asciiFullname="Jordan Auge"/>
	    <author surname="Carofiglio" initials="G." fullname="Giovanna Carofiglio"/>
	    <author initials="G." surname="Grassi"/>
	    <author initials="L." surname="Muscariello" fullname="Luca Muscariello"/>
	    <author initials="G." surname="Pau" fullname="Giovanni Pau"/>
	    <author initials="X." surname="Zeng"/>
	    <date month="June" year="2018"/>
	  </front>
	  <seriesInfo name="IEEE Transactions on Network," value="Volume 15, Issue 2"/>
	  <seriesInfo name="DOI" value="10.1109/TNSM.2018.2796720"/>
	</reference>


	<reference anchor="Carzaniga2011" target="https://conferences.sigcomm.org/sigcomm/2011/papers/icn/p56.pdf">
	  <front>
	    <title>Content-Based Publish/Subscribe Networking and Information-Centric Networking</title>
	    <author surname="Carzaniga" initials="A." fullname="Antonio Carzaniga"/>
	    <author surname="Papalini" initials="M." fullname="Michele Papaline"/>
	    <author surname="Wolf" initials="A.L." fullname="Alexander L. Wolf"/>
	    <date month="September" year="2011"/>
	  </front>
	  <seriesInfo name="DOI" value="10.1145/2018584.2018599"/>
	</reference>
	      
	<reference anchor="Mosko2017" target="https://arxiv.org/abs/1707.04738">
	  <front>
	    <title>CCNx 1.0 Bidirectional Streams</title>
	    <author surname="Mosko" initials="M." fullname="Marc Mosko"/>
	    <date month="July" year="2017"/>
	  </front>
	  <seriesInfo name="arXiv" value="1707.04738"/>
	</reference>

	<reference anchor="Moiseenko2014" target="https://dl.acm.org/doi/10.1145/2660129.2660152">
	  <front>
	    <title>Communication patterns for web interaction in named data networking</title>
	    <author surname="Moiseenko" initials="I." fullname="Ilya Moiseenko"/>
	    <author surname="Stapp" initials="M." fullname="Mark Stapp"/>
	    <author surname="Oran" initials="D." fullname="Dave Oran"/>
	    <date month="September" year="2014"/>
	  </front>
	  <seriesInfo name="DOI" value="10.1145/2660129.2660152"/>
	</reference>

	<reference anchor="Gasti2012" target="https://ieeexplore.ieee.org/document/6614127">
	  <front>
		<title>DoS and DDoS in Named Data Networking</title>
		<author surname="Gasti" initials="P." fullname="Paolo Gasti"/>
		<author surname="Tsudik" initials="G." fullname="Gene Tsudik"/>
		<author surname="Uzun" initials="Ersin" fullname="Ersin Uzun"/>
		<author surname="Zhang" initials="L." fullname="Lixia Zhang"/>
		<date month="August" year="2013"/>
	  </front>
	  <seriesInfo name="Proc. the 22nd International Conference on Computer Communication and Networks" value="(ICCCN)"/>
	  <seriesInfo name="DOI" value="10.1109/ICCCN.2013.6614127"/>
	</reference>
	
	<reference anchor="Baccelli2014" target="https://dl.acm.org/doi/abs/10.1145/2660129.2660144">
	  <front>
	  	<title>Information centric networking in the IoT: experiments with NDN in the wild</title>
	  	<author surname="Baccelli" initials="E." fullname="Emmanuel Baccelli"/>
	  	<author surname="Mehlis" initials="C." fullname="Christian Mehlis"/>
	  	<author surname="Hahm" initials="O." fullname="Oliver Hahm"/>
	  	<author surname="Schmidt" initials="T." fullname="Thomas Schmidt"/>
	  	<author surname="Wählisch" initials="M." fullname="Matthias Wählisch" asciiSurname="Wahlisch" asciiFullname="Matthias Wahlisch"/>
	  	<date month="September" year="2014"/>
	  </front>
	  <seriesInfo name="Proc. the 1st ACM Conference on Information-Centric Networking" value="(ICN '14)"/>
	  <seriesInfo name="DOI" value="10.1145/2660129.2660144"/>
	</reference>
	
	<reference anchor="Lindgren2016" target="https://ieeexplore.ieee.org/abstract/document/7444905">
	  <front>
	  	<title>Design choices for the IoT in Information-Centric Networks</title>
	  	<author surname="Lindgren" initials="A." fullname="Anders Lindgren"/>
	  	<author surname="Ben Abdessiem" initials="F." fullname="Fehmi Ben Abdesslem"/>
	  	<author surname="Ahlgren" initials="B." fullname="Bengt Ahlgren"/>
	  	<author surname="Schlelén" initials="O." fullname=" Olov Schelén" asciiSurname="Schelen" asciiFullname="Olov Schelen"/>
	  	<author surname="Malik" initials="A.M." fullname="Adeel Mohammad Malik"/>
	  	<date month="January" year="2016"/>
	  </front>
	  <seriesInfo name="Proc. the 13th IEEE Annual Consumer Communications and Networking Conference" value="(CCNC 2016)"/>
	  <seriesInfo name="DOI" value="10.1109/CCNC.2016.7444905"/>
	</reference>
	
	<reference anchor="Gundogan2018" target="https://dl.acm.org/doi/abs/10.1145/3267955.3269020">
	  <front>
	  	<title>HoPP: publish-subscribe for the constrained IoT</title>
	  	<author surname="Gündoğan" initials="C." fullname="Cenk Gündoğan" asciiFullname="Cenk Gundogan" asciiSurname="Gundogan"/>
	  	<author surname="Kietzmann" initials="P." fullname="Peter Kietzmann"/>
	  	<author surname="Schmidt" initials="T." fullname="Thomas Schmidt"/>
	  	<author surname="Wählisch" initials="M." fullname="Matthias Wählisch" asciiSurname="Wahlisch" asciiFullname="Wahlisch"/>
	  	<date month="September" year="2018"/>
	  </front>
	  <seriesInfo name="Proc. the 5th ACM Conference on Information-Centric Networking" value="(ICN '18)"/>
	  <seriesInfo name="DOI" value="10.1145/3267955.3269020"/>
	</reference>
	
	<reference anchor="Chen2015" target="https://ieeexplore.ieee.org/document/7312154">
	  <front>
	  	<title>NDSS: A Named Data Storage System, in International Conference on Cloud and Autonomic Computing</title>
	  	<author surname="Chen" initials="S." fullname="Shuo Chen"/>
	  	<author surname="Cao" initials="J." fullname="Junwei Cao"/>
	  	<author surname="Zhu" initials="L." fullname="Lipeng Zhu"/>
	  	<date month="September" year="2014"/>
	  </front>
	  <seriesInfo name="DOI" value="10.1109/ICCAC.2015.12"/>
	</reference>
	
	<reference anchor="DiBenedettoGTU12" target="https://www.ndss-symposium.org/ndss2012/andana-anonymous-named-data-networking-application">
	  <front>
		<title>ANDaNA: Anonymous Named Data Networking Application, in NDSS 2012</title>
		<author surname="DiBenedetto" initials="S." fullname="Steve Benedetto"/>
		<author surname="Gasti" initials="P." fullname="Paolo Gasti"/>
		<author surname="Tsudik" initials="G." fullname="Gene Tsudik"/>
		<author surname="Uzun" initials="E." fullname="Ersin Uzun"/>
		<date year="2102"/>
	  </front>
	  <seriesInfo name="DOI" value="https://arxiv.org/abs/1112.2205v2"/>
	</reference>
	
	<reference anchor="Ghali2017" target="https://dl.acm.org/doi/abs/10.1145/3125719.3125723">
	  <front>
	  	<title>When encryption is not enough: privacy attacks in content-centric networking</title>
	  	<author surname="Tsudik" initials="G." fullname="Gene Tsudik"/>
	  	<author surname="Ghali" initials="C." fullname="Cesar Ghali"/>
	  	<author surname="Wood" initials="C." fullname="Christopher Wood"/>
	  	<date month="September" year="2017"/>
	  </front>
	  <seriesInfo name="Proc. the 4th ACM Conference on Information-Centric Networking" value="(ICN '17)"/>
	  <seriesInfo name="DOI" value="https://doi.org/10.1145/3125719.3125723"/>
	</reference>
	
	<reference anchor="Arianfar2011" target="https://dl.acm.org/doi/10.1145/2018584.2018589">
	  <front>
	  	<title>On preserving privacy in content-oriented networks</title>
	  	<author surname="Arianfar" initials="S." fullname="Somaya Arianfar"/>
	  	<author surname="Koponen" initials="T." fullname="Teemu Koponen"/>
	  	<author surname="Raghavan" initials="B." fullname="Barath Raghavan"/>
	  	<author surname="Shenker" initials="S." fullname="Scott Shenker"/>
	  	<date month="August" year="2011"/>
	  </front>
	  <seriesInfo name="Proc. ACM SIGCOMM workshop on Information-Centric Networking" value="(ICN '11)"/>
	  <seriesInfo name="DOI" value="https://doi.org/10.1145/2018584.2018589"/>
	</reference>
	
	<reference anchor="So2013" target="https://ieeexplore.ieee.org/document/6665203">
	  <front>
	  	<title>Named data networking on a router: Fast and DoS-resistant forwarding with hash tables, in proceedings of Architectures for Networking and Communications Systems</title>
	  	<author surname="So" initials="W." fullname="Won So"/>
	  	<author surname="Narayanan" initials="A." fullname="Ashok Narayanan"/>
	  	<author surname="Oran" initials="D." fullname="David Oran"/>
	  	<date year="2013" month="October"/>
	  </front>
	  <seriesInfo name="DOI" value="10.1109/ANCS.2013.6665203"/>
	</reference>
	
	<reference anchor="Kutscher2022" target="https://dl.acm.org/doi/10.1145/3517212.3558089">
	  <front>
		<title>RESTful information-centric networking: statement</title>
		<author surname="Kutscher" initials="D."/>
		<author surname="Oran" initials="D."/>
		<date year="2022" month="September"/>
	  </front>
	  <seriesInfo name="Proc. the 9th ACM Conference on Information-Centric Networking" value="(ICN '22)"/>
	  <seriesInfo name="DOI" value="https://doi.org/10.1145/3517212.3558089"/>
	</reference>
	
	<reference anchor="Asaeda2019" target="https://search.ieice.org/bin/summary.php?id=e102-b_9_1792">
	  <front>
		<title>Cefore: Software Platform Enabling Content-Centric Networking and Beyond</title>
		<author surname="Asaeda" initials="H."/>
		<author surname="Ooka" initials="A."/>
		<author surname="Matsuzono" initials="K."/>
		<author surname="Li" initials="R."/>
		<date month="September" year="2019"/>
	  </front>
	  <seriesInfo name="IEICE Transactions on Communications," value="Vol.E102-B, No.9"/>
	  <seriesInfo name="DOI" value="10.1587/transcom.2018EII0001"/>
	</reference>

	<reference anchor="Cefore" target="https://github.com/cefore/">
	  <front>
	    <title>Cefore</title>
	    <author surname="Cefore development team"/>
	  </front>
	</reference>

  </references>

 <section anchor="rejected-alternatives"><name>Alternative Designs Considered</name>
 	<t>During development of this specification, a number of alternative designs were considered and at least partially documented. This appendix explains them for historical purposes, and explains why these were considered inferior to the design we settled on to carry forward.</t>
 	
 	<section anchor="fib-based-design"><name>Handling reflexive interests using dynamic FIB entries</name>
 		<t anchor="FIB-requirements">
	    The original draft specification employed the use of dynamically-created FIB entries for forwarding Reflexive Interests. In this approach,
	    at each forwarder along the reverse path from producer to
	    consumer, a FIB entry must be present that matches this
	    name via Longest Name Prefix Match (LNPM), so that when the reflexive interest
	    arrives, the forwarder can forward it downstream toward
	    the originating consumer. This FIB entry would point directly
	    to the incoming interface on which the corresponding
	    original Interest arrived. The FIB entry needs to be
	    created as part of the forwarding of the original Interest
	    so that it is available in time to catch any reflexive
	    Interest issued by the producer. It would usually make sense to
	    destroy this FIB entry when the Data message satisfying
	    the original Interest arrives since this avoids any
	    dangling stale state. Given the design details discussed
	    below, stale FIB state would not
	    represent a correctness hazard and hence could be done
	    lazily if desired in an implementation. </t>
	    
		<t>In this scheme, the forwarder operates as follows:</t>
       	<ol>
			<li>The forwarder creates short-lifetime FIB entries for any
	  Reflexive Interest Name prefixes communicated in an Interest
	  message. If the forwarder does not have sufficient resources
	  to do so, it rejects the Interest with the T_RETURN_NO_RESOURCES error — the same error used if the
	  forwarder were lacking sufficient PIT resources to process the Interest message.</li>
		<li>Those FIB entries are queried whenever an Interest
	  message arrives whose first name segment is of the type
	  <em>Reflexive Name Segment (RNP)</em></li>
		<li>The FIB entry gets removed eventually, after the
	  corresponding Data message has been forwarded. One option
	  would be to remove the FIB directly after the Data message
	  has been forwarded. However, the forwarder might choose do lazy
	  cleanup.</li>
      	</ol>
	<t>There are a number of additional considerations with this design that need to be dealt with.</t>
		<section anchor="FIB"><name>Design complexities and performance issues with FIB-based design</name>
		
   		<t>When processing an Interest containing the reflexive name TLV and creating the necessary FIB entry, the forwarder also creates a <em>back pointer</em> from that FIB entry to the PIT entry for the Interest message that created it. This PIT entry contains the current value of the remaining Interest lifetime or alternatively a value from which the remaining Interest lifetime can be easily computed. Call this value <em>IL<sub>t</sub></em>.</t>
   		
      	<t>The forwarder input thread could key off the high-order name segment type (one byte) and if reflexive,  do a reflexive FIB lookup instead of a full name hash. The reflexive FIB entry would contain the shard identity of the matching Interest (concretely, the core id servicing the shard) and steer the reflexive interest there. The reflexive name prefix FIB lookup would have to be competitive performance-wise with a full-name hash for this to win, however. Experimentation is needed to further evaluate such implementation tradeoffs for input packet load balancing in high-speed forwarders.</t>


   		<t>The FIB is a performance-critical data structure in any forwarder, as it needs to support relatively expensive longest name prefix match (LNPM) lookup algorithms. A number of well-known FIB data structures are heavily optimized for read access, since for normal Interest message processing the FIB changes slowly — only after topological changes or routing protocol updates. Support for reflexive names using dynamic FIB entries changes this, as FIB entries would be created and destroyed rapidly as Interest messages containing reflexive name TLVs are processed and the corresponding Data messages come back.</t>
      		
   		<t>While it may be feasible, especially in low-end forwarders handling a low packet forwarding rate to ignore this problem, for high-speed forwarders there are a number of hazards, including:</t>
      		<ol>
      			<li>If the entire FIB needs to be locked in order to insert or remove entries, this could cause inflated forwarding delays or in extreme cases, forwarding performance collapse.</li>
      			<li>A number of high-speed forwarder implementations employ a sharded PIT scheme (see <xref target="PIT-sharding"/>) to better parallelize forwarding across processing cores. The FIB, however, is still a shared data structure which is either read without read locks across cores, or explicitly copied such that there is a separate copy of the FIB for each PIT shard. Clearly, a high update rate without read locks and/or updating many copies of the FIB are unattractive implementation options. (Note: unlike the adopted scheme in the main specification, by just depending on a dynamic FIB it is not feasible to force reflexive interests to be hashed or be otherwise directed to the PIT shard holding the original Interest state).</li>
      		</ol>
      		
      		<t>There are any number of alternative FIB implementations that can work adequately. The most straightforward would be to simply implement a "special" FIB for just reflexive name lookups. This is feasible because reflexive names deterministically contain the distinguished high-order name segment type of T_REFLEXIVE_NAME, whose content is a 64-bit value that can be easily hashed to a FIB entry directly, avoiding the more expensive LNPM lookup. Inserts and deletes then devolve to the well-understood problem of hash table maintenance.</t>
      	</section>
      	<section anchor="FIB-and-interest-lifetime"><name>Interactions between FIB-based design and Interest Lifetime</name>	
      	<t>If Interest lifetime handling is implemented naively, it may run afoul of a sharded PIT forwarder implementation, since the PIT entry for the reflexive Interest and the PIT entry for the original Interest may be in different shards. Therefore, if the update is done cross-shard on each reflexive Interest arrival, performance may suffer, perhaps dramatically. Instead, the following approach to updating the Interest lifetime after computing the new value is would be needed by this FIB-based design for sharded-PIT forwarders.</t>
      		
      	<t>When creating the  reflexive FIB entry as above in <xref target="FIB"/>, copy the remaining Interest lifetime from the PIT entry. Do the PIT update if and only if this value is about to expire, thus paying the cross-shard update cost only if the original Interest is about to expire. A further optimization at the cost of modest extra complexity is to instead <em>queue</em> the update to the core holding the shard of the original PIT entry rather than doing the update directly. If the PIT entry expires or is satisfied, instead of removing it the associated core checks the update queue and does the necessary update.</t>	
		</section>
 	</section>
 	
 	<section anchor="path-steering-based-design"><name>Reflexive forwarding using Path Steering</name>
 		<t>We also considered leveraging Path Steering <xref
	    target="RFC9531"/> Path
	    Labels that inform the forwarder at each hop which
	    outgoing face to use for for forwarding the Reflexive
	    Interest. In this approach, the producer, when creating and issuing the
	    Reflexive Interest with the Reflexive Name Prefix includes
	     a Path Label to strictly steer the forwarding at all
	    hops from the producer to the consumer (strict mode Path
	    Steering). This means, the Reflexive Interest carries the
	    Reflexive Name Prefix, but forwarders do not apply LNPM or
	    any other outgoing face selection based on the
	    name. It also eliminates the need for dynamic FIB entries as discussed above in <xref target="fib-based-design"/>.
	    Instead the forwarding is strictly steered by the Path Label using regular Path Steering semantics.</t>
	    
	    <t>The message flow using Path Steering would look like the following:</t>
	    <figure anchor="path-steering-message-flow"><name>Message Flow Overview using Path Steering</name>
		  <artwork type="ascii-art" src="rf-path-steering.txt"/>
		  <artwork type="ascii-art">
    Legend:
    I1: Interest #1 containing the Reflexive Name Prefix TLV
    RI: Reflexive Interest with Reflexive Name Prefix Segment
    RNP: Reflexive Name Prefix
    D1: Data message, answering initiating I1 Interest
    D2: Data message, answering RI
		  </artwork>
		</figure>
  <t>
	Path Steering uses Path Label data structures on the
	downstream path (from producer to consumer) to discover and
	collect hop-by-hop forwarding information so that consumers
	can then specify selected paths for subsequent
	Interests. Reflexive Forwarding would use the
	same data structure, but for "reverse discovery", i.e., in the
	upstream direction from consumer to producer.
      </t>
	<t> From an operational perspective the path-steering approach does not exhibit good properties with respect to backward compatibility. Without a complete path of forwarders between consumer and producer that support path steering, reflexive interests cannot reach the intended consumer. While we might envision a way to	steer a subsequent Interest onto a working path as proposed in <xref target="RFC9531"/>, there is no	capability to force Interest routing away from an otherwise	working path not supporting the reflexive name TLV.</t>
	</section>
 	
 	<section anchor="multiple-rnps"><name>Multiple RNPs in a Trigger Interest</name>
 		<t>Early versions of the specification has an option to permit multiple Reflexive Name Prefixes in a Trigger Interest message if none of the other 3 options in <xref target="naming"/> covered the desired use case. The current specification does not permit this, because:</t>
 		<ul>
 			<li>It inflates the Trigger interest size, and would also inflate the trigger Data reponse size if the RNP is encoded as a name segment in the trigger interest name.</li>
 			<li>It is more likely a forwarder will reject the Interest for lack of resources.</li>
 			<li>No compelling use case has been found, at least so far</li>
		</ul>
	</section>

 </section>  
    
 <section><name>NDN Implementation</name>
 <t>
   An implementation of Reflexive Forwarind in NDN is available at
   https://github.com/nflsjxc/Reflexive-Forwarding-NDN-demo/tree/master. It
   differs from this specification in the following ways:
 </t>
 <section><name>Reflexive Name Segment</name>
 <t>
   Currently Reflexive Name Component is the suffix instead of the
   prefix for the Reflexive Names. This is easier for prefix matching
   in NFD.
 </t>
 </section>
 <section><name>Processing Reflexive Interests></name>
 <t>
   Currently we omit the RNP checking of Reflexive Interest with RNP
   in PIT entry because NFD now uses name-based PITs.
 </t>
 <t>
   Generally speaking there are 2 types of interests in the message flow:
 </t>
   <ol>
     <li>Reflexive Interest (Consumer -> Producer)</li>
     <li>Reflexive Interest (Producer -> Consumer)</li>
   </ol>
   <t>
     Currently the two types of Interests are identified by the
     Reflexive Name value, if RN=9999, then it is the Reflexive Interest
     from Producer to Consumer.
   </t>
 </section>
 </section>

 
      <!-- Change Log
	   v00 2020-03-15  DRO/DK Initial version
	   v02 2022-02-16  Major re-work to switch to PIT tokens
	   v03 2022-06-04  Changes to address Ken Calvert comments
	   v04 2022-11-28  Keepalive + chage Dirk's affiliation
	   v05 2023-03-15  QAddress Hitoshi Asaeda's comments
	   
	   v00 2023-03-01  Convert to adopted ICNRG version
	   v01 2024-11-01  Get rid of PIT Tokens, modifications per Hitoshi's comments
      -->
 </back>
</rfc>
  
